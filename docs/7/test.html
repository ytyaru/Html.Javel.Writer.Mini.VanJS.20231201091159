<script src="../lib/van/1.2.6/nomodule.min.js"></script>
<script src="util/string/length.js"></script>
<script>
const { em, ruby, rt, rp } = van.tags
const text = 'ğŸ˜„ã“ã‚Œã¯ã€Šã€Šå¼·èª¿ã€‹ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚' // ã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒšã‚¢ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã¨å­—æ•°ä½ç½®ãŒç‹‚ã£ã¦ã—ã¾ã†
//const text = 'ã“ã‚Œã¯ã€Šã€Šå¼·èª¿ã€‹ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚'
const matchs = {
    'em': [...text.matchAll(/ã€Šã€Š([^\n]{1,50}?)ã€‹ã€‹/g)],
    'rubyS': [...text.matchAll(/([ä¸€-é¾ ã€…ä»ã€†ã€‡ãƒ¶]{1,50})ã€Š([^ï½œã€Šã€‹\n\r]{1,20})ã€‹/g)],
    'rubyL': [...text.matchAll(/ï½œ([^ï½œã€Šã€‹\n\r]{1,50})ã€Š([^ï½œã€Šã€‹\n\r]{1,20})ã€‹/g)],
}
console.log(matchs)
function matchsEm(text) { // ã€Šã€Šå¼·èª¿ã€‹ã€‹
    const matchs = []
    for (let i=0; i<text.Graphemes.length; i++) {
        if (i===text.Graphemes.length-1) { continue }
        const g1 = text.Graphemes[i]
        const g2 = text.Graphemes[i+1]
        if ('ã€Š'!==g1 || 'ã€Š'!==g2) { continue }
        for (let k=i+2; k<text.Graphemes.length; k++) {
            if (text.Graphemes.length-1<=k) { continue }
            //if (k===text.Graphemes.length-1) { continue }
            const g3 = text.Graphemes[k]
            const g4 = text.Graphemes[k+1]
            if ('ã€‹'!==g3 || 'ã€‹'!==g4) { continue }
            const len = k - (i+1) - 1 // g3 - g2 - 1
            if (len < 2 || 50 < len) { continue }

            const emTxt = text.Graphemes.slice(i+2, k) // (g2+1, g3)
            if (emTxt.includes('\n')) { continue }
            //matchs.push({index:i, length:len, html:em(text.Graphemes.slice(i+2, k))})  // (g2+1, g3)
            //matchs.push({index:i, length:(k+1)-i+1, html:em(text.Graphemes.slice(i+2, k))})  // (g2+1, g3)
            matchs.push({index:i, length:(k+1)-i+1, html:em(emTxt)})
            break
        }
    }
    return matchs
}
console.log(matchsEm('ğŸ˜„ã“ã‚Œã¯ã€Šã€Šå¼·èª¿ã€‹ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚'))
console.log(matchsEm('ğŸ˜„ã“ã‚Œã¯ã€Šã€Šå¼·èª¿ã€‹ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚ã€Šã€Šè¤‡æ•°ã€‹ã€‹ã‚ã£ã¦ã‚‚OKï¼'))

function matchsLongRuby(text) { // ï½œã‚ã„ã†ãˆãŠã€Šã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã€‹
    const matchs = []
    const graphemes = text.Graphemes
    for (let i=0; i<graphemes .length; i++) {
        if (i===graphemes.length-1) { continue }
        const pipe = graphemes[i]
        if ('ï½œ'!==pipe) { continue }
        const pipeNext = graphemes[i+1]
        if ('ã€Š'===pipeNext) { continue } // ã€Šã€‹ãƒ¡ã‚¿æ–‡å­—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        for (let k=i+2; k<graphemes.length; k++) {
            if (graphemes.length-1<=k) { continue }
            const r1 = graphemes[k]
            if ('ã€Š'!==r1) { continue }
            const rbTxt = graphemes.slice(i+1, k)
            const baseLen = k - i
            if (50 < baseLen) { continue } // è¦ªæ–‡å­—50å­—ä»¥ä¸Šã¯é•·ã™ãã‚‹ã®ã§å¯¾è±¡å¤–
            const r1Prev = graphemes[k-1]
            if ('ï½œ'===r1Prev) { continue } // ã€Šã€‹ãƒ¡ã‚¿æ–‡å­—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
            if ('ã€Š'===r1Prev) { continue } // em
            const r1Next = graphemes[k+1]
            if ('ã€Š'===r1Next) { continue } // em
            for (let m=k+2; m<graphemes.length; m++) {
                if (graphemes.length-1<=m) { continue }
                const r2 = graphemes[m]
                if ('ã€‹'!==r2) { continue }
                const rtTxt = graphemes.slice(k+1, m)
                const rtLen = m - k
                if (20 < rtLen) { continue } // ãƒ«ãƒ“æ–‡å­—20å­—ä»¥ä¸Šã¯é•·ã™ãã‚‹ã®ã§å¯¾è±¡å¤–
                if (graphemes.slice(i, m).includes('\n')) { continue } // é€”ä¸­ã«æ”¹è¡ŒãŒã‚ã‚‹ã¨ç„¡åŠ¹
                matchs.push({index:i, length:m-i+1, html:ruby(rbTxt, rp('ï¼ˆ'), rt(rtTxt), rp('ï¼‰'))})  // (g2+1, g3)
                break
            }
            break
        }
    }
    return matchs
}
console.log(matchsLongRuby('ã“ã‚Œã¯ï½œé€ã‚Šä»®åã€Šãƒ«ãƒ“ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚'))
console.log(matchsLongRuby('ã“ã‚Œã¯ï½œé€ã‚Šä»®åã€Šãƒ«ãƒ“ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚ï½œè¤‡æ•°ã€Šãµãã™ã†ã€‹ã‚ã£ã¦ã‚‚OKï¼'))


function isKanji(g) {
    const G = g.codePointAt(0)
    const KANJI_MIN = 'ä¸€'.codePointAt(0)
    const KANJI_MAX = 'é¾ '.codePointAt(0)
    const KANJI_ANO = ['ã€…','ä»','ã€†','ã€‡','ãƒ¶'].map(k=>k.codePointAt(0))
    if (KANJI_MIN <= G && G <= KANJI_MAX) { return true }
    if (KANJI_ANO.some(k=>k===G)) { return true }
    return false
}
//    #SHORT = /([ä¸€-é¾ ã€…ä»ã€†ã€‡ãƒ¶]{1,50})ã€Š([^ï½œã€Šã€‹\n\r]{1,20})ã€‹/g
//    #LONG = /ï½œ([^ï½œã€Šã€‹\n\r]{1,50})ã€Š([^ï½œã€Šã€‹\n\r]{1,20})ã€‹/g
//    #ESCAPE = /ï½œã€Š/g
function matchsShortRuby(text) { // æ¼¢å­—ã€Šã‹ã‚“ã˜ã€‹
    const matchs = []
    const graphemes = text.Graphemes
    for (let i=0; i<graphemes.length; i++) {
        const r1 = graphemes[i]
        if ('ã€Š'!==r1) { continue }
        const K = i;
        for (let k=i-1; 0<=k; k--) {
            if (!isKanji(graphemes[k]) && 'ï½œ'===graphemes[k]) { break } // éæ¼¢å­—ãªã‚‰ãƒ«ãƒ“å¯¾è±¡å¤–ã€‚ï½œãªã‚‰LongRubyã®å¯èƒ½æ€§æœ‰ã§å¯¾è±¡å¤–
            K = k
        }
        if (K===i) { continue } // è¦ªæ–‡å­—ï¼ˆæ¼¢å­—ï¼‰ãŒãªã„
        const rbTxt = graphemes.slice(K, i)
        for (let m=i+2; m<graphemes.length; m++) {
            const r2 = graphemes[m]
            if ('ã€‹'!==r2) { continue }
            const rtTxt = graphemes.slice(i+1, m)
            matchs.push({index:i, length:m-i+1, html:ruby(rbTxt, rp('ï¼ˆ'), rt(rtTxt), rp('ï¼‰'))})
            break
        }
    }
    return matchs
}
console.log(matchsShortRuby('ã“ã‚Œã¯æ¼¢å­—ã€Šã‹ã‚“ã˜ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚'))
console.log(matchsShortRuby('ã“ã‚Œã¯æ¼¢å­—ã€Šã‹ã‚“ã˜ã€‹ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚è¤‡æ•°ã€Šãµãã™ã†ã€‹ã‚ã£ã¦ã‚‚OKï¼'))

function matchsRuby(text) { // æ¼¢å­—ã€Šã‹ã‚“ã˜ã€‹, ï½œã‚ã„ã†ãˆãŠã€Šã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã€‹
    if (!(text.includes('ã€Š') && text.includes('ã€‹'))) { return [] }
    const matchs = [...matchsLongRuby(text), ...matchsShortRuby(text)].flat()
    return matchs.sort((a,b)=>a.index < b.index)
}
function matchsEmRuby(text) { // æ¼¢å­—ã€Šã‹ã‚“ã˜ã€‹, ï½œã‚ã„ã†ãˆãŠã€Šã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã€‹
    if (!(text.includes('ã€Š') && text.includes('ã€‹'))) { return [] }
    const matchs = [...matchsEm(text), ...matchsLongRuby(text), ...matchsShortRuby(text)].flat()
    return matchs.sort((a,b)=>a.index < b.index)
}
function makeInnerHtml(text) {
    const matches = matchsEmRuby(text)
    const spans = []
    const start = 0
    for (let i=0; i<matches.length; i++) {
        const length = matches[i].index
        spans.push({index:start, length:length, html:span(text.slice(start, length))})
        start = matches[i].index + matches[i].length
    }
    matches.extends(spans).sort((a,b)=>a.index < b.index)
    return matches.map(m=>m.html)
}

console.log(matchsInnerHtml('ã“ã‚Œã¯è¤‡åˆã€Šãµãã”ã†ã€‹ã€Šã€Šãƒ†ã‚¹ãƒˆã€‹ã€‹ã§ã™ã€‚ï½œã‚ã„ã†ãˆãŠã€Šã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã€‹ã€‚'.repeat(2)))
</script>
